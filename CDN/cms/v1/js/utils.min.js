/* u stands for utilities.  These are common to all types of solutions and therefore always loaded.  It will be a lot lighter than previous utils as there is no consideration beyond modern browser capabilities.

utilities include calculations, array handling, object handling, server time retrieval 
Usage:

Using parameters both in both public and private methods

params.name

Private methods calling private methods:

_privateMethod()

Public methods calling private methods:

_privateMethod()

Public methods calling public methods:

this.publicMethod()

Private methods cannot call public methods.

Calling public methods via the public interface

s_utils.publicMethod()

*/

"use strict";
const s_Utils = function () {
    let resizeTimer;
    let _observerListeners = [],
        win = window,
        observerDoc = win.document,
        MutationObserver = win.MutationObserver || win.WebKitMutationObserver,
        observer;

    const _afterResizeEvent = () => {
        /* Creates an event that is triggered after window resize has finished 
        Usage:  window.addEventListener('afterresize', function (e) {  }, false); */
        const afterResize = new Event('afterresize');

        window.addEventListener('resize', function (e) {

            if (resizeTimer) {
                clearTimeout(resizeTimer);
                resizeTimer = null;
            }

            resizeTimer = setTimeout(function () {
                /*resizing has stopped */
                window.dispatchEvent(afterResize);
            }, 250);

        });
    }

    const _registerEvents = () => {
        _afterResizeEvent();
    }

    const _setStyleSheet = (id, url) => {
        document.getElementById(id).setAttribute('href', url);
    }

    const _el = (el) => {
        /*When multiple pages exists this function must know the context, either from the store or another variable. */
        /* Receives an element as a string ("#myId" or ".myClass" or obj)  or as an element and always returns the element if it is in the DOM 
        Can also receive 'body' or 'main' and returns the respective object.
        */
        if (el == null) {
            console.log("Error: s_utils.el received a null parameter.")
            return false;
        }

        if (_isString(el)) {
            let elLowercase = el.toLowerCase().trim()
            if (elLowercase == "body") {
                return document.body;
            }
            if (elLowercase == "main") {
                return document.getElementsByTagName("main")[0];
            }
            if (el.startsWith("#")) {
                el = document.getElementById(el);
            } else {
                if (el.startsWith(".")) {
                    el = el.substring(1)
                }
                el = document.getElementsByClassName("el");
            }
        }

        return el;
    }

    const _insertComponent = (parent, id) => {
        /*Uses the id to find the component's HTML and then inserts it into the parent element. */
        //comp = document.getElementById(id)
        /*Retrieve components html and apply to DOM */
        //containerObj.innerHTML = "componentsHTML"
    }

    const _addHTML = (el, html, position) => {
        /* Not currently used but could be useful. */
        if (position == null || position.indexOf('beforebegin afterbegin beforeend afterend') === -1) {
            position = 'beforeend';
        }
        el.insertAdjacentHTML(position, html);
    }


    const _loadHTML = (url, containerObj, insertType, callbackFn) => {
        /*Load an html document, via AJAX, into a container element.
        oldElIdToreplace is only required for replace and passed for performance.
            if no container element is specified then return the ajax response string.
            insertType: 1. "replace" - replace whatever contents is in the container.
            2. "append" - append html to the container
            3. "prepend" - prepend html to the container.  
        */
        let xhttp = new XMLHttpRequest();
        let retVal = true;

        xhttp.onreadystatechange = function () {

            if (this.readyState == 4 && this.status == 200) {
                if (insertType === "replace") {
                    //alert(containerObj.firstElementChild.id)
                    let frag = document.createRange().createContextualFragment(this.responseText)
                    containerObj.replaceChild(frag, containerObj.firstElementChild);
                    //containerObj.innerHTML = this.responseText;
                }
                if (insertType === "append") {
                    containerObj.insertAdjacentHTML('beforeend', this.responseText)
                }
                if (insertType === "prepend") {
                    let theFirstChild = containerObj.firstChild;
                    containerObj.insertAdjacentHTML('afterbegin', this.responseText)
                }

            } else {
                retVal = "error status:" + this.status;
            }

        };
        xhttp.open("GET", url, true);
        xhttp.send();
        callbackFn(retVal);
    }

    const _getDoc = (url, callbackFn) => {
        /* Uses AJAX just like _loadHTML but instead of inserting the response it applies it as a parameter to a callback function.  */
        let time = performance.now();


        let xhttp;
        xhttp = new XMLHttpRequest();
        xhttp.withCredentials = true;
        xhttp.onreadystatechange = function () {
            if (this.readyState == 4 && this.status == 200) {
                let TimeTaken = `Ajax took ${Math.round(performance.now() - time)} milliseconds.`;
                console.log(TimeTaken);
                callbackFn(this.responseText);

            }
        };
        xhttp.open("GET", url, true);
        xhttp.send();
    }

    const _elFullScreen = function makeFullscreen(elem, hor, vert) {
        /* not perfect, may need to store the elements id and original size so that we can restore
        also this function just causes the element to expand instantly, it would be better to have 
        a transitional expand and factor in persisting the original values for restore. */
        let vertical = vert;
        let horizontal = hor;
        if (horizontal === undefined) {
            horizontal = true;
        }
        if (vertical === undefined) {
            vertical = true;
        }
        elem.style.position = 'absolute';
        if (horizontal) {
            elem.style.left = 0;
            elem.style.right = 0;
        }
        if (vertical) {
            elem.style.top = 0;
            elem.style.bottom = 0;
        }
    }

    const _getScrollbarWidth = (element) => {
        if (element == null) {
            return 0;
        }
        if (element === document.body || element === "body" || element === "html") {
            return window.innerWidth - document.documentElement.clientWidth;
        } else {
            element = _el(element)
            return element.offsetWidth - element.clientWidth;
        }
    }

    const _isString = (obj) => obj === obj + '';

    const _isBoolean = (obj) => obj === false || obj === true;

    const _isArray = (obj) => Array.isArray(obj)

    const _isNumber = (obj) => obj === obj + 0;

    const _isFunction = (obj) => Object.prototype.toString.call(obj) === '[object Function]';

    const _isObject = (obj) => obj === Object(obj)

    const _removeZeros = (numb) => parseFloat(numb)

    const _removeDuplicates = (arr) => [...new Set(arr)]

    const _returnDuplicates = (arr) => arr.filter((item, index) => arr.indexOf(item) !== index);

    const _percentage = (partialValue, totalValue) => _removeZeros(((partialValue / 100) * totalValue).toFixed(2));

    const _percentageOf = (xPercent, yValue) => _removeZeros(((xPercent / yValue) * 100).toFixed(2));

    const _percentageChange = (fromNumber, toNumber) => {
        let decreaseValue = toNumber - fromNumber;
        return _removeZeros(((decreaseValue / fromNumber) * 100).toFixed(2));
    }

    const _heightToPercent = (element) => {
        if (element == null || parentEl == null) {
            return false;
        }
        return _percentage(element.clientHeight, element.parentElement.clientHeight)
    }

    const _widthToPercent = (element) => {
        if (element == null || parentEl == null) {
            return false;
        }
        return _percentage(element.clientWidth, element.parentElement.clientWidth)
    }

    const _percentToPixels = (percent, parentElement, blnHeight) => {
        let px;
        if (blnHeight) {
            px = parentElement.clientWidth
        } else {
            px = parentElement.clientWidth
        }
        if (_isNumber(px)) {
            return _percentage(percent, px)
        } else {
            return false;
        }
    }

    const _stringToArray = (str) => {
        if (_isString(str)) {
            let arr = str.split(",");
            return arr.map(a => a.trim());
        } else {
            return [];
        }
    }

    const _removeClasses = (el, classes) => {
        if (typeof classes === "string") {
            classes = classes.split(",");
            classes = classes.map(s => s.trim());
        }
        el.classList.remove(...classes);
    }

    const _removeClassByPrefix = (el, prefix) => {
        var regx = new RegExp('\\b' + prefix + '.*?\\b', 'g');
        [...el.classList].forEach(className => {
            regx.test(className) && el.classList.remove(className);
        });
    }

    const _replaceClassAll = (currentClass, newClass) => {
        /*Finds all occurences of current Class and replaces them with the newClass*/
        let occurenceCount;
        let els = document.getElementsByClassName(currentClass);
        occurenceCount = els.length;
        while (occurenceCount--) {
            els[occurenceCount].className = newClass;
        }
    }

    const _toggleClassAll = (class1, class2) => {
        let occurenceCount;
        let newClass = class2;
        let els = document.getElementsByClassName(class1);
        occurenceCount = els.length;
        if (occurenceCount < 1) {
            els = document.getElementsByClassName(class2);
            occurenceCount = els.length;
            newClass = class1;
        }
        while (occurenceCount--) {
            els[occurenceCount].className = newClass;
        }
    }
    const _viewportSize = () => {
        return {
            width: window.innerWidth * window.devicePixelRatio,
            height: window.innerHeight * window.devicePixelRatio
        };
    }

    const _elPos = (el) => {

        var xPos = 0;
        var yPos = 0;

        while (el) {
            if (el.tagName == "BODY") {
                // deal with browser quirks with body/window/document and page scroll
                var xScroll = el.scrollLeft || document.documentElement.scrollLeft;
                var yScroll = el.scrollTop || document.documentElement.scrollTop;

                xPos += (el.offsetLeft - xScroll + el.clientLeft);
                yPos += (el.offsetTop - yScroll + el.clientTop);
            } else {

                // for all other non-BODY elements
                xPos += (el.offsetLeft - el.scrollLeft + el.clientLeft);
                yPos += (el.offsetTop - el.scrollTop + el.clientTop);

            }

            el = el.offsetParent;
        }
        return {
            x: xPos,
            y: yPos
        };
    }

    const _IdInDOM = (elId = "") => {
        /* Check to see if an element exists in the DOM
           If it isn't "undefined" and it isn't "null", then it exists. 
           we return the element as that allows us to use it or get its parent.
           This is more useful and efficient than returning true.*/
        if (elId === "") {
            return false;
        }
        let el = document.getElementById(elId);

        if (typeof (el) != 'undefined' && el != null) {
            return el;
        } else {
            return false;
        }
    }
    const _ElParentId = (elId = "") => {
        /*Get parentID by performing safe checks. */
        if (elId === "") {
            return false;
        }
        let el = document.getElementById(elId);
        if (typeof (el) != 'undefined' && el != null) {
            /* So element exists */
            let elParent = el.parentElement
            if (elParent === null) {
                return false;
            }
            let elParentId = el.parentElement.id
            if (elParentId === undefined || elParentId === undefined === null) {
                return false;
            }
            return elParentId;
        }


    }

    const _elIsLoaded = (selector, fn) => {
        // Store the selector and callback to be monitored
        /* _observerListeners.push({
             selector: selector,
             fn: fn
         }); */

        _observerListeners[0] = {
            selector: selector,
            fn: fn
        };
        if (!observer) {
            // Watch for changes in the observerDocument
            observer = new MutationObserver(_checkElLoaded);
            observer.observe(observerDoc.documentElement, {
                childList: true,
                subtree: true
            });
        }
        // Check if the element is currently in the DOM
        _checkElLoaded();
    }

    const _checkElLoaded = () => {
        /* Used by the _elLoaded method */
        // Check the DOM for elements matching a stored selector
        for (let i = 0, len = _observerListeners.length, listener, elements; i < len; i++) {
            listener = _observerListeners[i];
            // Query for elements matching the specified selector
            elements = observerDoc.querySelectorAll(listener.selector);
            for (let j = 0, jLen = elements.length, element; j < jLen; j++) {
                element = elements[j];
                // Make sure the callback isn't invoked with the 
                // same element more than once
                if (!element.ready) {
                    element.ready = true;
                    // Invoke the callback with the element
                    listener.fn.call(element, element);
                }
            }
        }
    }




    /* Public Methods */
    return {
        init: function () {
            _registerEvents();
        },

        params: function (defaultParams, userParams) {
            /*Combines the default parameters with the developer specified parameters
            if no developer parameters have been specified then the defaultParams are returned as they were. */
            if (userParams != null && userParams != undefined
                && userParams != 'undefined') {
                for (var opt in defaultParams) {
                    if (userParams[opt] != null
                        && userParams[opt] != undefined
                        && userParams[opt] != 'undefined') {
                        defaultParams[opt] = userParams[opt];
                    }
                }
            }
            return defaultParams;
        },
        viewportSize: function () {
            /* Using Window.innerwidth fails to return the correct width on retina displays
            due to pixel density.  This function corrects that issue. 
            Usage: let viewPortSize = s_utils.viewportSize(); 
            console.log(viewPortSize.width);console.log(viewPortSize.height) */
            return _viewportWidth()
        },
        el: function (elstring) {
            //Returns and element by id (with or without #), "body" or "main"
            return _el(elstring)
        },
        IdInDOM: function (elId) {
            return _IdInDOM(elId)
        },
        elLoaded: function (selector, fn) {

            /* http://ryanmorr.com/using-mutation-observers-to-watch-for-element-availability/ 
            Observes when an element is loaded into the DOM using MutationObserver then triggers 
            a callback.
            
            Usage: s_rt.elLoaded('._v_loaded', function(element) {
                // do something
            });
            
            */
            _IdInDOM(selector)
            _elIsLoaded(selector, fn);
        },
        ElParentId: function (elId) {
            return _ElParentId(elId);
        },
        elPos: function (el) {
            /*Receives an element and returns its x,y coords 
            usage:
            let position = s_utils.elPos(myElement);
    console.log("The image is located at: " + position.x + ", " + position.y);
            */
            el = _el(el);
            return _elPos(el)
        },
        getScrollbarWidth(el) {
            return _getScrollbarWidth(el);
        },
        getSelectValue(el) {
            /*Receives a select element as an id or as an object and returns value */
            el = _el(el);
            return el.options[el.selectedIndex].value;
        },
        setStyleSheet: function (id, url) {
            /*defaultParams: id - is the id of the stylesheet link tag
            url - is the path of the replacement stylesheet. */
            id = _el(id);
            _setStyleSheet(id, url)
        },
        addHTML(el, html, position) {
            /*el can be "body","main" or an id  */
            /* html the html to inseert */
            /* position:
            'beforebegin': Before the element itself.
            'afterbegin': Just inside the element, before its first child.
            'beforeend': Just inside the element, after its last child. DEFAULT
            'afterend': After the element itself.
            */
            el = _el(el)
            _addHTML(el, html, position);

        },

        loadHTML(HTMLDoc, containerObj, insertType, callbackFn) {
            _loadHTML(HTMLDoc, containerObj, insertType, callbackFn)
        },

        getDoc(url, callbackFn) {
            _getDoc(url, callbackFn);
        },

        removeZeros: function (numb) {
            /*Receives a number and if it has pointless zeros after the decimal point these are removed. */
            return _removeZeros(numb);
        },
        removeDuplicates(arr) {
            /* Receives an array and removes duplicates */
            return _removeDuplicates(arr);

        },
        returnDuplicates(arr) {
            /* Receives an array and returns any duplicates */
            return _returnDuplicates(arr);
        },
        percentage: function (partialValue, totalValue) {
            /* Receives two numbers and returns a percentage that represents what the partialValue is of the totalValue  Example 30 is what percent of 450. */
            return _percentage(partialValue, totalValue)
        },
        percentageOf: function (xPercent, yValue) {
            /* Returns the percentage that x% is of y. E.G. retVal = utils.percentageOf(20,200); retVal will equal 10. */
            return _percentageOf(xPercent, yValue)
        },
        percentageChange: function (fromNumber, toNumber) {
            /*Useful for determining by what percentage the new number as increased over the old number.  
            Could be used to calculate new customer since last month. */
            return _percentageChange(fromNumber, toNumber)
        },
        heightToPercent: function (el) {
            /*Receives an element and then returns a percentage value that represents the elements percentage of its parent height.*/
            return _heightToPercent(el);
        },
        widthToPercent: function (el) {
            /*Receives an element and then returns a percentage value that represents the elements percentage of its parent width. */
            return _widthToPercent(el);
        },
        percentToPixelsHeight: function (percent, parentElement) {
            /* Receives a percentage and a parentElement then returns a value that represents the percent in pixels of the parents height.  */
            return _percentToPixels(percent, parentElement, true)
        },
        percentToPixelsWidth: function (percent, parentElement) {
            /* Receives a percentage and a parentElement then returns a value that represents the percent in pixels of the parents width.  */
            return _percentToPixels(percent, parentElement, false)
        },

        template: function (str, json) {
            /*Simple template utility that recieves a string and a json object and repeats the string for every
            element in the json object. */
        },
        isObject: function isObject(obj) {
            return _isObject(obj)
        },
        isArray: function (obj) {
            return _isArray(obj)
        },
        isNumber: function (obj) {
            return obj === obj + 0;
        },
        isString: function (obj) {
            return _isString(obj);
        },
        isBoolean: function isBoolean(obj) {
            return _isBoolean(obj)
        },
        isFunction: function isFunction(obj) {
            return _isFunction(obj)
        },
        stringToArray: function (str) {
            /*Must contain commas, the strings will be trimmed */
            return _stringToArray(str)
        },
        removeClasses: function (el, classes) {
            /* Receives an array or string of class names and removes them 
            accepted format ["first","second","third"]
            "first,second,third" */
            _removeClasses(el, classes)
        },
        removeClassByPrefix(el, prefix) {
            /* Receives an element and removes all classes starting with the prefix */
            _removeClassByPrefix(el, prefix)
        },
        replaceClassAll: function (currentClass, newClass) {
            /*Finds all occurences of current Class and replaces them with the newClass*/
            _replaceClassAll(currentClass, newClass)
        },
        toggleClassAll: function (class1, class2) {
            /*Works like replaceClassAll, but in a smarter way.  If class1 exists it replaces it with class2.
            If class1 does not exist it replaces class2 with class1.  */
            _toggleClassAll(class1, class2)
        },
        elementFullScreen: function (el, hor, ver) {
            /*Expands the element to to requestFullScreen mode. If hor (horitontal) or ver (vertical) are omitted then they will be set to true in the function by default.  */
            _elFullScreen(element, hor, ver);
        },
        debounce: (fn, time) => {
            /*Explanation: https://medium.com/@TCAS3/debounce-deep-dive-javascript-es6-e6f8d983b7a1
            Example Usage:
            window.addEventListener('resize', s_utils.debounce((e) => {
                console.log(e);
            }, 300));
            */
            let timeout;

            return function () {
                const functionCall = () => fn.apply(this, arguments);

                clearTimeout(timeout);
                timeout = setTimeout(functionCall, time);
            }
        },
        ready: (fn) => {
            /* Can be used to determine when the DOM is fully loaded 
            /*Example Usage:
            s_utils.ready(function () {
                console.log("ready")
            });
            */
            if (document.readyState !== 'loading') {
                fn();
            } else {
                document.addEventListener('DOMContentLoaded', fn);
            }
        }
    };

}
